//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

// #[cfg(feature = "proto")]
pub mod proto_types_parsers {
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use crate::proto_def;

    use crate::types::ConfigParams;
    impl IntoProto<proto_def::ConfigParams> for ConfigParams {
        fn into_proto(self) -> proto_def::ConfigParams {
            proto_def::ConfigParams {
                migration_authority: self.migration_authority.map(|x| x.to_string()),
                backend_authority: self.backend_authority.map(|x| x.to_string()),
                config_authority: self.config_authority.map(|x| x.to_string()),
                helio_fee: self.helio_fee.map(|x| x.to_string()),
                dex_fee: self.dex_fee.map(|x| x.to_string()),
                fee_bps: self.fee_bps.map(|x| x.into()),
                dex_fee_share: self.dex_fee_share.map(|x| x.into()),
                migration_fee: self.migration_fee,
                linear_curve_mcap_threshold: self.linear_curve_mcap_threshold,
                marketcap_currency: self.marketcap_currency.map(|x| x.into()),
                min_supported_decimal_places: self.min_supported_decimal_places.map(|x| x.into()),
                max_supported_decimal_places: self.max_supported_decimal_places.map(|x| x.into()),
                min_supported_token_supply: self.min_supported_token_supply,
                max_supported_token_supply: self.max_supported_token_supply,
                coef_b: self.coef_b,
                constant_product_v1_mcap_threshold: self.constant_product_v1_mcap_threshold,
                constant_product_v2_mcap_threshold: self.constant_product_v2_mcap_threshold,
            }
        }
    }
    use crate::types::MigrationEvent;
    impl IntoProto<proto_def::MigrationEvent> for MigrationEvent {
        fn into_proto(self) -> proto_def::MigrationEvent {
            proto_def::MigrationEvent {
                tokens_migrated: self.tokens_migrated,
                tokens_burned: self.tokens_burned,
                collateral_migrated: self.collateral_migrated,
                fee: self.fee,
                label: self.label,
            }
        }
    }
    use crate::types::TradeEvent;
    impl IntoProto<proto_def::TradeEvent> for TradeEvent {
        fn into_proto(self) -> proto_def::TradeEvent {
            proto_def::TradeEvent {
                amount: self.amount,
                collateral_amount: self.collateral_amount,
                dex_fee: self.dex_fee,
                helio_fee: self.helio_fee,
                allocation: self.allocation,
                curve: self.curve.to_string(),
                cost_token: self.cost_token.to_string(),
                sender: self.sender.to_string(),
                trade_type: self.trade_type as i32,
                label: self.label,
            }
        }
    }
    use crate::types::TradeParams;
    impl IntoProto<proto_def::TradeParams> for TradeParams {
        fn into_proto(self) -> proto_def::TradeParams {
            proto_def::TradeParams {
                token_amount: self.token_amount,
                collateral_amount: self.collateral_amount,
                fixed_side: self.fixed_side.into(),
                slippage_bps: self.slippage_bps,
            }
        }
    }
}
